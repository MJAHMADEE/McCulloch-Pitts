# -*- coding: utf-8 -*-
"""HW1_Q1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Po4mEPD9Ep5xRAD-Ouai0XfS-vtl3q4q
"""

class McCullochPittsNeuron:
    def __init__(self, weights, threshold, bias=0):
        self.weights = weights
        self.bias = bias
        self.threshold = threshold

    def fire(self, inputs):
        weighted_sum = sum(w * x for w, x in zip(self.weights, inputs)) + self.bias
        if weighted_sum >= self.threshold:
            return 1
        else:
            return 0

class ThreeInputThreeOutputNetwork:
    def __init__(self):
        self.neuron_D = McCullochPittsNeuron([1, 1, -1], 1)
        self.neuron_F1 = McCullochPittsNeuron([-1, 1], 1)
        self.neuron_F = McCullochPittsNeuron([1, -1], 1)

    def predict(self, inputs):
        A, B, C = inputs
        D = self.neuron_D.fire([A, B, C])
        E_inputs = [A, C]
        E = self.neuron_D.fire(E_inputs)
        F1 = self.neuron_F1.fire([B, C])
        F_inputs = [A, F1]
        F = self.neuron_F.fire(F_inputs)
        return D, E, F

# Test the network for all possible input states
network = ThreeInputThreeOutputNetwork()

for A in range(2):
    for B in range(2):
        for C in range(2):
            D, E, F = network.predict([A, B, C])
            print(f"Input: ({A}, {B}, {C}) --> Output: ({D}, {E}, {F})")

class McCullochPittsNeuron:
    def __init__(self, weights, threshold, bias=0):
        self.weights = weights
        self.bias = bias
        self.threshold = threshold

    def fire(self, inputs):
        weighted_sum = sum(w * x for w, x in zip(self.weights, inputs)) + self.bias
        if weighted_sum >= self.threshold:
            return 1
        else:
            return 0

class ThreeInputThreeOutputNetwork:
    def __init__(self):
        self.neuron_D = McCullochPittsNeuron([1, 1, -1], 1)
        self.neuron_F1 = McCullochPittsNeuron([-1, 1], 1)
        self.neuron_E = McCullochPittsNeuron([1, 1], 1)
        self.neuron_F = McCullochPittsNeuron([1, -1], 1)

    def predict(self, inputs):
        A, B, C = inputs
        D = self.neuron_D.fire([A, B, C])
        E_inputs = [A, C]
        E = self.neuron_E.fire(E_inputs)
        F1 = self.neuron_F1.fire([B, C])
        F_inputs = [A, F1]
        F = self.neuron_F.fire(F_inputs)
        return D, E, F

# Test the network for all possible input states
network = ThreeInputThreeOutputNetwork()

for A in range(2):
    for B in range(2):
        for C in range(2):
            D, E, F = network.predict([A, B, C])
            print(f"Input: ({A}, {B}, {C}) --> Output: ({D}, {E}, {F})")

0# Test the network with initial state A=0, B=0
network = ThreeInputThreeOutputNetwork()

# Define the initial state
A, B = 0, 0

while True:
    # Get the input C
    C = int(input("Enter input C (0 or 1): "))

    # Get the next state and acceptance
    D, E, F = network.predict([A, B, C])

    # Print the output
    print(f"Current state: ({A}, {B}), Input: {C} --> Next state: ({D}, {E}), Acceptance: {F}")

    # Update the current state
    A, B = D, E

    # Check if the acceptance is 1, and break the loop if it is
    if F == 1:
        print("Acceptance reached!")
        break

# Test the network with initial state A=0, B=0
network = ThreeInputThreeOutputNetwork()

# Define the initial state
A, B = 0, 0

while True:
    # Get the input C
    C = int(input("Enter input C (0 or 1): "))

    # Get the next state and acceptance
    D, E, F = network.predict([A, B, C])

    # Print the output
    print(f"Current state: ({A}, {B}), Input: {C} --> Next state: ({D}, {E}), Acceptance: {F}")

    # Update the current state
    A, B = D, E

    # Check if the acceptance is 1, and break the loop if it is
    if F == 1:
        print("Acceptance reached!")
        break

# Take input from user
current_state = [int(x) for x in input("Enter current state A,B (separated by comma): ").split(',')]
C = int(input("Enter input C: "))
next_state = current_state.copy()

# Test the network for the given input
network = ThreeInputThreeOutputNetwork()

# Flag variable to track if F=1 has occurred previously or not
f_occurred = False

while True:
    D, E, F = network.predict([current_state[0], current_state[1], C])
    next_state[0], next_state[1] = D, E
    if F == 1 and not f_occurred:
        f_occurred = True
    else:
        current_state = next_state.copy()
        C = int(input("Enter input C: "))
    
    # Print output only if F=1 has occurred previously or F is not equal to 1
    if f_occurred or F != 1:
        print(f"Current State: ({current_state[0]}, {current_state[1]}) --> Input: {C} --> Next State: ({next_state[0]}, {next_state[1]}) --> Acceptance: {F}")

    if f_occurred:
        break

# Print the final output
print(f"Current State: ({current_state[0]}, {current_state[1]}) --> Input: {C} --> Next State: ({next_state[0]}, {next_state[1]}) --> Acceptance: {F}")

# Take input from user
current_state = [int(x) for x in input("Enter current state A,B (separated by comma): ").split(',')]
C = int(input("Enter input C: "))
next_state = current_state.copy()

# Test the network for the given input
network = ThreeInputThreeOutputNetwork()

while True:
    D, E, F = network.predict([current_state[0], current_state[1], C])
    next_state[0], next_state[1] = D, E
    if F == 1:
        break
    current_state = next_state.copy()
    C = int(input("Enter input C: "))
    
# Print the final output
print(f"Current State: ({current_state[0]}, {current_state[1]}) --> Input: {C} --> Next State: ({next_state[0]}, {next_state[1]}) --> Acceptance: {F}")

# Take input from user
current_state = [int(x) for x in input("Enter current state A,B (separated by comma): ").split(',')]
C = int(input("Enter input C: "))
next_state = current_state.copy()

# Test the network for the given input
network = ThreeInputThreeOutputNetwork()

# Flag variable to track if F=1 has occurred previously or not
f_occurred = False

while True:
    D, E, F = network.predict([current_state[0], current_state[1], C])
    next_state[0], next_state[1] = D, E
    if F == 1 and not f_occurred:
        f_occurred = True
    else:
        current_state = next_state.copy()
        C = int(input("Enter input C: "))
    
    # Print output only if F=1 has occurred previously or F is not equal to 1
    if f_occurred or F != 1:
        print(f"Current State: ({current_state[0]}, {current_state[1]}) --> Input: {C} --> Next State: ({next_state[0]}, {next_state[1]}) --> Acceptance: {F}")

    if f_occurred:
        break

# Print the final output
print(f"Current State: ({current_state[0]}, {current_state[1]}) --> Input: {C} --> Next State: ({next_state[0]}, {next_state[1]}) --> Acceptance: {F}")

"""# Other Try (may wrong!)"""

class McCullochPittsNeuron:
    def __init__(self, weights, threshold, bias=0):
        self.weights = weights
        self.bias = bias
        self.threshold = threshold

    def fire(self, inputs):
        weighted_sum = sum(w * x for w, x in zip(self.weights, inputs)) + self.bias
        if weighted_sum >= self.threshold:
            return 1
        else:
            return 0

class ThreeInputThreeOutputNetwork:
    def __init__(self):
        self.neuron_D = McCullochPittsNeuron([1, 1, -1], 1)
        self.neuron_F1 = McCullochPittsNeuron([1, -1], 1)
        self.neuron_F = McCullochPittsNeuron([1, 1], 1)

    def predict(self, inputs):
        A, B, C = inputs
        D = self.neuron_D.fire([A, B, C])
        E_inputs = [A, C]
        E = self.neuron_F.fire(E_inputs)
        F1 = self.neuron_F1.fire([A, C])
        F_inputs = [A, F1]
        F = self.neuron_F.fire(F_inputs)
        return D, E, F

# Test the network for all possible input states
network = ThreeInputThreeOutputNetwork()

for A in range(2):
    for B in range(2):
        for C in range(2):
            D, E, F = network.predict([A, B, C])
            print(f"Input: ({A}, {B}, {C}) --> Output: ({D}, {E}, {F})")

class McCullochPittsNeuron:
    def __init__(self, weights, threshold, bias=0):
        self.weights = weights
        self.bias = bias
        self.threshold = threshold

    def fire(self, inputs):
        weighted_sum = sum(w * x for w, x in zip(self.weights, inputs)) + self.bias
        if weighted_sum >= self.threshold:
            return 1
        else:
            return 0


class ThreeInputThreeOutputNetwork:
    def __init__(self):
        self.neuron_D = McCullochPittsNeuron([1, 1, -1], 1)
        self.neuron_E = McCullochPittsNeuron([1, 0, 1], 1)
        self.neuron_F1 = McCullochPittsNeuron([1, 0], 1)
        self.neuron_F2 = McCullochPittsNeuron([1, -1], 1)
        self.neuron_F = McCullochPittsNeuron([1, 1], 1)

    def predict(self, inputs):
        A, B, C = inputs
        D = self.neuron_D.fire([A, B, C])
        E = self.neuron_E.fire([A, B, C])
        F1 = self.neuron_F1.fire([A, B])
        F2 = self.neuron_F2.fire([A, C])
        F_inputs = [F1, F2]
        F = self.neuron_F.fire(F_inputs)
        return D, E, F


# Test the network for all possible input states
network = ThreeInputThreeOutputNetwork()

for A in range(2):
    for B in range(2):
        for C in range(2):
            D, E, F = network.predict([A, B, C])
            print(f"Input: ({A}, {B}, {C}) --> Output: ({D}, {E}, {F})")

class McCullochPittsNeuron:
    def __init__(self, weights, threshold, bias=0):
        self.weights = weights
        self.bias = bias
        self.threshold = threshold

    def fire(self, inputs):
        weighted_sum = sum(w * x for w, x in zip(self.weights, inputs)) + self.bias
        if weighted_sum >= self.threshold:
            return 1
        else:
            return 0


class ThreeInputThreeOutputNetwork:
    def __init__(self):
        self.neuron_D = McCullochPittsNeuron([1, 1, -1], 1)
        self.neuron_E = McCullochPittsNeuron([1, 0, 1], 1)
        self.neuron_F1 = McCullochPittsNeuron([1, 0], 1)
        self.neuron_F2 = McCullochPittsNeuron([1, -1], 1)

    def predict(self, inputs):
        A, B, C = inputs
        D = self.neuron_D.fire([A, B, C])
        E = self.neuron_E.fire([A, B, C])
        F1 = self.neuron_F1.fire([A, B])
        F2 = self.neuron_F2.fire([A, C])
        F = F1 or F2
        return D, E, F


# Test the network for all possible input states
network = ThreeInputThreeOutputNetwork()

for A in range(2):
    for B in range(2):
        for C in range(2):
            D, E, F = network.predict([A, B, C])
            print(f"Input: ({A}, {B}, {C}) --> Output: ({D}, {E}, {F})")

class McCullochPittsNeuron:
    def __init__(self, weights, threshold):
        self.weights = weights
        self.threshold = threshold

    def fire(self, inputs):
        weighted_sum = sum(w * x for w, x in zip(self.weights, inputs))
        if weighted_sum >= self.threshold:
            return 1
        else:
            return 0


class ThreeInputThreeOutputNetwork:
    def __init__(self):
        self.neuron_D = McCullochPittsNeuron([1, 1, -1], 1) # (A+B)C' + AB
        self.neuron_E = McCullochPittsNeuron([1, 0, 1], 1) # A + C
        self.neuron_F1 = McCullochPittsNeuron([1, 0], 1) # A
        self.neuron_F2 = McCullochPittsNeuron([1, -1], 1) # A'C + AB

    def predict(self, inputs):
        A, B, C = inputs
        D = self.neuron_D.fire([A, B, C])
        E = self.neuron_E.fire([A, B, C])
        F1 = self.neuron_F1.fire([A, B])
        F2 = self.neuron_F2.fire([A, C])
        F = F1 or F2
        return D, E, F


# Test the network for all possible input states
network = ThreeInputThreeOutputNetwork()

for A in range(2):
    for B in range(2):
        for C in range(2):
            D, E, F = network.predict([A, B, C])
            print(f"Input: ({A}, {B}, {C}) --> Output: ({D}, {E}, {F})")

import networkx as nx
import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for inputs, neurons, and outputs
G.add_nodes_from(['A', 'B', 'C', 'Neuron_D', 'Neuron_E', 'Neuron_F1', 'Neuron_F2', 'D', 'E', 'F'])

# Add edges to represent connections between nodes
G.add_edges_from([('A', 'Neuron_D'), ('B', 'Neuron_D'), ('C', 'Neuron_D')])
G.add_edges_from([('A', 'Neuron_F1'), ('B', 'Neuron_F1'), ('C', 'Neuron_F1')])
G.add_edges_from([('A', 'Neuron_F2'), ('B', 'Neuron_F2'), ('C', 'Neuron_F2')])
G.add_edges_from([('Neuron_D', 'D')])
G.add_edges_from([('Neuron_E', 'E')])
G.add_edges_from([('Neuron_F1', 'F')])
G.add_edges_from([('Neuron_F2', 'F')])

# Set positions for the nodes
pos = {'A': (0, 2), 'B': (0, 1), 'C': (0, 0), 'Neuron_D': (1, 1.5), 'Neuron_E': (1, 0.5), 'Neuron_F1': (2, 1), 'Neuron_F2': (2, 0), 'D': (3, 1.5), 'E': (3, 0.5), 'F': (4, 1)}

# Draw the graph
nx.draw(G, pos, with_labels=True)

# Save the plot as a PDF file
plt.savefig('network_plot.pdf')

import networkx as nx
import matplotlib.pyplot as plt

# Define the network
network = ThreeInputThreeOutputNetwork()

# Define input, neurons, and output nodes
input_nodes = ['A', 'B', 'C']
neuron_nodes = ['D', 'E', 'F1', 'F2']
output_nodes = ['D', 'E', 'F']

# Create a directed graph
G = nx.DiGraph()

# Add the nodes
G.add_nodes_from(input_nodes, color='blue')
G.add_nodes_from(neuron_nodes, color='orange')
G.add_nodes_from(output_nodes, color='green')

# Add the edges with weights
G.add_edge('A', 'D', weight=1)
G.add_edge('B', 'D', weight=1)
G.add_edge('C', 'D', weight=-1)
G.add_edge('A', 'E', weight=1)
G.add_edge('B', 'E', weight=0)
G.add_edge('C', 'E', weight=1)
G.add_edge('A', 'F1', weight=1)
G.add_edge('B', 'F1', weight=0)
G.add_edge('A', 'F2', weight=1)
G.add_edge('C', 'F2', weight=-1)
G.add_edge('F1', 'F', weight=1)
G.add_edge('F2', 'F', weight=1)

# Get positions of nodes
pos = nx.shell_layout(G, [input_nodes, neuron_nodes, output_nodes])

# Draw the nodes and edges
nx.draw_networkx_nodes(G, pos, node_color=[G.nodes[n]['color'] for n in G.nodes()])
nx.draw_networkx_edges(G, pos, edge_color='gray', width=1, alpha=0.5, arrowsize=20, arrowstyle='->')

# Draw the edge weights
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)

# Set the axis off and show the plot
plt.axis('off')
plt.show()

class McCullochPittsNeuron:
    def __init__(self, weights, threshold, bias):
        self.weights = weights
        self.bias = bias
        self.threshold = threshold

    def fire(self, inputs):
        weighted_sum = sum(w * x for w, x in zip(self.weights, inputs)) + self.bias
        if weighted_sum >= self.threshold:
            return 1
        else:
            return 0


class ThreeInputThreeOutputNetwork:
    def __init__(self):
        self.neuron_D1 = McCullochPittsNeuron([1, 1, 0], 0, -2)
        self.neuron_D2 = McCullochPittsNeuron([2, 2, -1], 0, -2)
        self.neuron_F1 = McCullochPittsNeuron([0, 1, -1], 0, 2)

    def predict(self, inputs):
        A, B, C = inputs
        D1 = self.neuron_D1.fire([A, B, C])
        D2 = self.neuron_D2.fire([A, B, C])
        D = D1 or D2
        E = A or C
        F1 = self.neuron_F1.fire([A, B, C])
        F = A and F1
        return D, E, F


# Test the network for all possible input states
network = ThreeInputThreeOutputNetwork()

for A in range(2):
    for B in range(2):
        for C in range(2):
            D, E, F = network.predict([A, B, C])
            print(f"Input: ({A}, {B}, {C}) --> Output: ({D}, {E}, {F})")

class McCullochPittsNeuron:
    def __init__(self, weights, threshold):
        self.weights = weights
        self.threshold = threshold

    def fire(self, inputs):
        weighted_sum = sum(w * x for w, x in zip(self.weights, inputs))
        if weighted_sum >= self.threshold:
            output = 1
        else:
            output = 0
        print(f"Inputs: {inputs}, Weights: {self.weights}, Threshold: {self.threshold}, Output: {output}")
        return output


class ThreeInputThreeOutputNetwork:
    def __init__(self):
        self.neuron_D = McCullochPittsNeuron([1, 1, -1], 1) # (A+B)C' + AB
        self.neuron_E = McCullochPittsNeuron([1, 0, 1], 1) # A + C
        self.neuron_F1 = McCullochPittsNeuron([1, 0], 1) # A
        self.neuron_F2 = McCullochPittsNeuron([1, -1], 1) # A'C + AB

    def predict(self, inputs):
        A, B, C = inputs
        D = self.neuron_D.fire([A, B, C])
        E = self.neuron_E.fire([A, B, C])
        F1 = self.neuron_F1.fire([A, B])
        F2 = self.neuron_F2.fire([A, C])
        F = F1 or F2
        print(f"Inputs: ({A}, {B}, {C}) --> Outputs: (D:{D}, E:{E}, F1:{F1}, F2:{F2}, F:{F})")
        return D, E, F


# Test the network for all possible input states
network = ThreeInputThreeOutputNetwork()

for A in range(2):
    for B in range(2):
        for C in range(2):
            D, E, F = network.predict([A, B, C])
            print(f"Input: ({A}, {B}, {C}) --> Output: ({D}, {E}, {F})")

class McCullochPittsNeuron:
    def __init__(self, weights, threshold):
        self.weights = weights
        self.threshold = threshold

    def fire(self, inputs):
        weighted_sum = sum(w * x for w, x in zip(self.weights, inputs))
        if weighted_sum >= self.threshold:
            return 1
        else:
            return 0


class ThreeInputThreeOutputNetwork:
    def __init__(self):
        self.neuron_D = McCullochPittsNeuron([1, 1, -1], 1) # (A+B)C' + AB
        self.neuron_E = McCullochPittsNeuron([1, 0, 1], 1) # A + C
        self.neuron_F1 = McCullochPittsNeuron([1, 0], 1) # A
        self.neuron_F2 = McCullochPittsNeuron([1, -1], 1) # A'C + AB

    def predict(self, inputs):
        A, B, C = inputs
        
        # Calculate the output of neuron D
        weighted_sum_D = sum(w * x for w, x in zip(self.neuron_D.weights, [A, B, C]))
        threshold_D = self.neuron_D.threshold
        if weighted_sum_D >= threshold_D:
            D_output = 1
        else:
            D_output = 0
        
        # Calculate the output of neuron E
        weighted_sum_E = sum(w * x for w, x in zip(self.neuron_E.weights, [A, B, C]))
        threshold_E = self.neuron_E.threshold
        if weighted_sum_E >= threshold_E:
            E_output = 1
        else:
            E_output = 0
        
        # Calculate the output of neuron F1
        weighted_sum_F1 = sum(w * x for w, x in zip(self.neuron_F1.weights, [A, B]))
        threshold_F1 = self.neuron_F1.threshold
        if weighted_sum_F1 >= threshold_F1:
            F1_output = 1
        else:
            F1_output = 0
        
        # Calculate the output of neuron F2
        weighted_sum_F2 = sum(w * x for w, x in zip(self.neuron_F2.weights, [A, C]))
        threshold_F2 = self.neuron_F2.threshold
        if weighted_sum_F2 >= threshold_F2:
            F2_output = 1
        else:
            F2_output = 0
        
        # Calculate the final output F using the outputs of F1 and F2
        if F1_output == 1 or F2_output == 1:
            F_output = 1
        else:
            F_output = 0
        
        return D_output, E_output, F_output


# Test the network for all possible input states
network = ThreeInputThreeOutputNetwork()

for A in range(2):
    for B in range(2):
        for C in range(2):
            D, E, F = network.predict([A, B, C])
            print(f"Input: ({A}, {B}, {C}) --> Output: (D: {D}, E: {E}, F: {F})")

class McCullochPittsNeuron:
    def __init__(self, weights, threshold):
        self.weights = weights
        self.threshold = threshold

    def fire(self, inputs):
        weighted_sum = sum(w * x for w, x in zip(self.weights, inputs))
        if weighted_sum >= self.threshold:
            return 1
        else:
            return 0


class ThreeInputThreeOutputNetwork:
    def __init__(self):
        self.neuron_D = McCullochPittsNeuron([1, 1, -1], 1) # (A+B)C' + AB
        self.neuron_E = McCullochPittsNeuron([1, 0, 1], 1) # A + C
        self.neuron_F1 = McCullochPittsNeuron([1, 0], 1) # A
        self.neuron_F2 = McCullochPittsNeuron([1, -1], 1) # A'C + AB

    def predict(self, inputs):
        A, B, C = inputs
        D = self.neuron_D.fire([A, B, C])
        E = self.neuron_E.fire([A, B, C])
        F1 = self.neuron_F1.fire([A, B])
        F2 = self.neuron_F2.fire([A, C])
        F = F1 or F2
        return D, E, F


# Test the network for all possible input states
network = ThreeInputThreeOutputNetwork()

for A in range(2):
    for B in range(2):
        for C in range(2):
            D, E, F = network.predict([A, B, C])
            print(f"\t\t[A]--(1)-----[D]\nInput: ({A}, {B}, {C}) -->\t\t  |\n\t\t[C]--(1)--[F1]     |   [E]--(1)--[B]\n\t\t\t     \\     |\n\t\t\t       \\(1)--[F2]")
            print(f"Output: ({D}, {E}, {F})\n")